// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.3
//   protoc               v5.28.1
// source: backend/version.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export interface GetVersionRequest {
  productId: string;
}

export interface GetSpecifiedVersionRequest {
  productId: string;
  versionId: string;
}

export interface GetVersionResponse {
  id: string;
  productId: string;
  createdAt: string;
  updatedAt: string;
  details: GetVersionResponse_Detail[];
}

export interface GetVersionResponse_Detail {
  id: string;
  key: string;
  value: string;
  createdAt: string;
  updatedAt: string;
}

export interface ListVersionsRequest {
  productId: string;
}

export interface ListVersionsResponse {
  data: ListVersionsResponse_Version[];
}

export interface ListVersionsResponse_Version {
  id: string;
  productId: string;
  createdAt: string;
  updatedAt: string;
  details: ListVersionsResponse_Version_Detail[];
}

export interface ListVersionsResponse_Version_Detail {
  id: string;
  key: string;
  value: string;
  createdAt: string;
  updatedAt: string;
}

function createBaseGetVersionRequest(): GetVersionRequest {
  return { productId: "" };
}

export const GetVersionRequest: MessageFns<GetVersionRequest> = {
  encode(message: GetVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetVersionRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionRequest>, I>>(base?: I): GetVersionRequest {
    return GetVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionRequest>, I>>(object: I): GetVersionRequest {
    const message = createBaseGetVersionRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetSpecifiedVersionRequest(): GetSpecifiedVersionRequest {
  return { productId: "", versionId: "" };
}

export const GetSpecifiedVersionRequest: MessageFns<GetSpecifiedVersionRequest> = {
  encode(message: GetSpecifiedVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.versionId !== "") {
      writer.uint32(18).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpecifiedVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpecifiedVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpecifiedVersionRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
    };
  },

  toJSON(message: GetSpecifiedVersionRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSpecifiedVersionRequest>, I>>(base?: I): GetSpecifiedVersionRequest {
    return GetSpecifiedVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSpecifiedVersionRequest>, I>>(object: I): GetSpecifiedVersionRequest {
    const message = createBaseGetSpecifiedVersionRequest();
    message.productId = object.productId ?? "";
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseGetVersionResponse(): GetVersionResponse {
  return { id: "", productId: "", createdAt: "", updatedAt: "", details: [] };
}

export const GetVersionResponse: MessageFns<GetVersionResponse> = {
  encode(message: GetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(34).string(message.updatedAt);
    }
    for (const v of message.details) {
      GetVersionResponse_Detail.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details.push(GetVersionResponse_Detail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => GetVersionResponse_Detail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetVersionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => GetVersionResponse_Detail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionResponse>, I>>(base?: I): GetVersionResponse {
    return GetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionResponse>, I>>(object: I): GetVersionResponse {
    const message = createBaseGetVersionResponse();
    message.id = object.id ?? "";
    message.productId = object.productId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.details = object.details?.map((e) => GetVersionResponse_Detail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetVersionResponse_Detail(): GetVersionResponse_Detail {
  return { id: "", key: "", value: "", createdAt: "", updatedAt: "" };
}

export const GetVersionResponse_Detail: MessageFns<GetVersionResponse_Detail> = {
  encode(message: GetVersionResponse_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionResponse_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionResponse_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionResponse_Detail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: GetVersionResponse_Detail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVersionResponse_Detail>, I>>(base?: I): GetVersionResponse_Detail {
    return GetVersionResponse_Detail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVersionResponse_Detail>, I>>(object: I): GetVersionResponse_Detail {
    const message = createBaseGetVersionResponse_Detail();
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseListVersionsRequest(): ListVersionsRequest {
  return { productId: "" };
}

export const ListVersionsRequest: MessageFns<ListVersionsRequest> = {
  encode(message: ListVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: ListVersionsRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVersionsRequest>, I>>(base?: I): ListVersionsRequest {
    return ListVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVersionsRequest>, I>>(object: I): ListVersionsRequest {
    const message = createBaseListVersionsRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseListVersionsResponse(): ListVersionsResponse {
  return { data: [] };
}

export const ListVersionsResponse: MessageFns<ListVersionsResponse> = {
  encode(message: ListVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      ListVersionsResponse_Version.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(ListVersionsResponse_Version.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsResponse {
    return {
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => ListVersionsResponse_Version.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListVersionsResponse): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => ListVersionsResponse_Version.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVersionsResponse>, I>>(base?: I): ListVersionsResponse {
    return ListVersionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVersionsResponse>, I>>(object: I): ListVersionsResponse {
    const message = createBaseListVersionsResponse();
    message.data = object.data?.map((e) => ListVersionsResponse_Version.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListVersionsResponse_Version(): ListVersionsResponse_Version {
  return { id: "", productId: "", createdAt: "", updatedAt: "", details: [] };
}

export const ListVersionsResponse_Version: MessageFns<ListVersionsResponse_Version> = {
  encode(message: ListVersionsResponse_Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(34).string(message.updatedAt);
    }
    for (const v of message.details) {
      ListVersionsResponse_Version_Detail.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsResponse_Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsResponse_Version();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details.push(ListVersionsResponse_Version_Detail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsResponse_Version {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => ListVersionsResponse_Version_Detail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListVersionsResponse_Version): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ListVersionsResponse_Version_Detail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVersionsResponse_Version>, I>>(base?: I): ListVersionsResponse_Version {
    return ListVersionsResponse_Version.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVersionsResponse_Version>, I>>(object: I): ListVersionsResponse_Version {
    const message = createBaseListVersionsResponse_Version();
    message.id = object.id ?? "";
    message.productId = object.productId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.details = object.details?.map((e) => ListVersionsResponse_Version_Detail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListVersionsResponse_Version_Detail(): ListVersionsResponse_Version_Detail {
  return { id: "", key: "", value: "", createdAt: "", updatedAt: "" };
}

export const ListVersionsResponse_Version_Detail: MessageFns<ListVersionsResponse_Version_Detail> = {
  encode(message: ListVersionsResponse_Version_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsResponse_Version_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsResponse_Version_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsResponse_Version_Detail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ListVersionsResponse_Version_Detail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVersionsResponse_Version_Detail>, I>>(
    base?: I,
  ): ListVersionsResponse_Version_Detail {
    return ListVersionsResponse_Version_Detail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVersionsResponse_Version_Detail>, I>>(
    object: I,
  ): ListVersionsResponse_Version_Detail {
    const message = createBaseListVersionsResponse_Version_Detail();
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

export interface VersionService {
  GetVersion(request: GetSpecifiedVersionRequest): Promise<GetVersionResponse>;
  GetPrimaryVersion(request: GetVersionRequest): Promise<GetVersionResponse>;
  GetRandomVersion(request: GetVersionRequest): Promise<GetVersionResponse>;
  ListVersions(request: ListVersionsRequest): Promise<ListVersionsResponse>;
}

export const VersionServiceServiceName = "backend.VersionService";
export class VersionServiceClientImpl implements VersionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || VersionServiceServiceName;
    this.rpc = rpc;
    this.GetVersion = this.GetVersion.bind(this);
    this.GetPrimaryVersion = this.GetPrimaryVersion.bind(this);
    this.GetRandomVersion = this.GetRandomVersion.bind(this);
    this.ListVersions = this.ListVersions.bind(this);
  }
  GetVersion(request: GetSpecifiedVersionRequest): Promise<GetVersionResponse> {
    const data = GetSpecifiedVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetVersion", data);
    return promise.then((data) => GetVersionResponse.decode(new BinaryReader(data)));
  }

  GetPrimaryVersion(request: GetVersionRequest): Promise<GetVersionResponse> {
    const data = GetVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPrimaryVersion", data);
    return promise.then((data) => GetVersionResponse.decode(new BinaryReader(data)));
  }

  GetRandomVersion(request: GetVersionRequest): Promise<GetVersionResponse> {
    const data = GetVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRandomVersion", data);
    return promise.then((data) => GetVersionResponse.decode(new BinaryReader(data)));
  }

  ListVersions(request: ListVersionsRequest): Promise<ListVersionsResponse> {
    const data = ListVersionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListVersions", data);
    return promise.then((data) => ListVersionsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
