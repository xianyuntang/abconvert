// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.3
//   protoc               v5.28.1
// source: backend/testing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export interface StartTestingRequest {
  productId: string;
  details: StartTestingRequest_Detail[];
}

export interface StartTestingRequest_Detail {
  key: string;
  value: string;
}

export interface StartTestingResponse {
  message: string;
}

export interface GetRunningTestingRequest {
  productId: string;
}

export interface GetRunningTestingResponse {
  id?: string | undefined;
}

export interface StopTestingRequest {
  productId: string;
}

export interface StopTestingResponse {
  message: string;
}

export interface GetTestingResultRequest {
  productId: string;
  testingId: string;
}

export interface GetTestingResultResponse {
  primary: GetTestingResultResponse_Statistics | undefined;
  testing: GetTestingResultResponse_Statistics | undefined;
  clickElements: string[];
}

export interface GetTestingResultResponse_Statistics {
  visits: number;
  averageTimeOnPage: number;
  clickMap: { [key: string]: number };
}

export interface GetTestingResultResponse_Statistics_ClickMapEntry {
  key: string;
  value: number;
}

export interface GetTestingRequest {
  productId: string;
}

export interface GetTestingResponse {
  data: GetTestingResponse_Testing[];
}

export interface GetTestingResponse_Testing {
  id: string;
  primaryVersionId: string;
  testingVersionId: string;
  createdAt: string;
}

function createBaseStartTestingRequest(): StartTestingRequest {
  return { productId: "", details: [] };
}

export const StartTestingRequest: MessageFns<StartTestingRequest> = {
  encode(message: StartTestingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    for (const v of message.details) {
      StartTestingRequest_Detail.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTestingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTestingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details.push(StartTestingRequest_Detail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTestingRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => StartTestingRequest_Detail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartTestingRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => StartTestingRequest_Detail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartTestingRequest>, I>>(base?: I): StartTestingRequest {
    return StartTestingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartTestingRequest>, I>>(object: I): StartTestingRequest {
    const message = createBaseStartTestingRequest();
    message.productId = object.productId ?? "";
    message.details = object.details?.map((e) => StartTestingRequest_Detail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartTestingRequest_Detail(): StartTestingRequest_Detail {
  return { key: "", value: "" };
}

export const StartTestingRequest_Detail: MessageFns<StartTestingRequest_Detail> = {
  encode(message: StartTestingRequest_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTestingRequest_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTestingRequest_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTestingRequest_Detail {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StartTestingRequest_Detail): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartTestingRequest_Detail>, I>>(base?: I): StartTestingRequest_Detail {
    return StartTestingRequest_Detail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartTestingRequest_Detail>, I>>(object: I): StartTestingRequest_Detail {
    const message = createBaseStartTestingRequest_Detail();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStartTestingResponse(): StartTestingResponse {
  return { message: "" };
}

export const StartTestingResponse: MessageFns<StartTestingResponse> = {
  encode(message: StartTestingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTestingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTestingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTestingResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: StartTestingResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartTestingResponse>, I>>(base?: I): StartTestingResponse {
    return StartTestingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartTestingResponse>, I>>(object: I): StartTestingResponse {
    const message = createBaseStartTestingResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetRunningTestingRequest(): GetRunningTestingRequest {
  return { productId: "" };
}

export const GetRunningTestingRequest: MessageFns<GetRunningTestingRequest> = {
  encode(message: GetRunningTestingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunningTestingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunningTestingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunningTestingRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetRunningTestingRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRunningTestingRequest>, I>>(base?: I): GetRunningTestingRequest {
    return GetRunningTestingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRunningTestingRequest>, I>>(object: I): GetRunningTestingRequest {
    const message = createBaseGetRunningTestingRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetRunningTestingResponse(): GetRunningTestingResponse {
  return { id: undefined };
}

export const GetRunningTestingResponse: MessageFns<GetRunningTestingResponse> = {
  encode(message: GetRunningTestingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunningTestingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunningTestingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunningTestingResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : undefined };
  },

  toJSON(message: GetRunningTestingResponse): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRunningTestingResponse>, I>>(base?: I): GetRunningTestingResponse {
    return GetRunningTestingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRunningTestingResponse>, I>>(object: I): GetRunningTestingResponse {
    const message = createBaseGetRunningTestingResponse();
    message.id = object.id ?? undefined;
    return message;
  },
};

function createBaseStopTestingRequest(): StopTestingRequest {
  return { productId: "" };
}

export const StopTestingRequest: MessageFns<StopTestingRequest> = {
  encode(message: StopTestingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopTestingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopTestingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopTestingRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: StopTestingRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopTestingRequest>, I>>(base?: I): StopTestingRequest {
    return StopTestingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopTestingRequest>, I>>(object: I): StopTestingRequest {
    const message = createBaseStopTestingRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseStopTestingResponse(): StopTestingResponse {
  return { message: "" };
}

export const StopTestingResponse: MessageFns<StopTestingResponse> = {
  encode(message: StopTestingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopTestingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopTestingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopTestingResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: StopTestingResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopTestingResponse>, I>>(base?: I): StopTestingResponse {
    return StopTestingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopTestingResponse>, I>>(object: I): StopTestingResponse {
    const message = createBaseStopTestingResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetTestingResultRequest(): GetTestingResultRequest {
  return { productId: "", testingId: "" };
}

export const GetTestingResultRequest: MessageFns<GetTestingResultRequest> = {
  encode(message: GetTestingResultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.testingId !== "") {
      writer.uint32(18).string(message.testingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResultRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      testingId: isSet(object.testingId) ? globalThis.String(object.testingId) : "",
    };
  },

  toJSON(message: GetTestingResultRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.testingId !== "") {
      obj.testingId = message.testingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResultRequest>, I>>(base?: I): GetTestingResultRequest {
    return GetTestingResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResultRequest>, I>>(object: I): GetTestingResultRequest {
    const message = createBaseGetTestingResultRequest();
    message.productId = object.productId ?? "";
    message.testingId = object.testingId ?? "";
    return message;
  },
};

function createBaseGetTestingResultResponse(): GetTestingResultResponse {
  return { primary: undefined, testing: undefined, clickElements: [] };
}

export const GetTestingResultResponse: MessageFns<GetTestingResultResponse> = {
  encode(message: GetTestingResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primary !== undefined) {
      GetTestingResultResponse_Statistics.encode(message.primary, writer.uint32(10).fork()).join();
    }
    if (message.testing !== undefined) {
      GetTestingResultResponse_Statistics.encode(message.testing, writer.uint32(18).fork()).join();
    }
    for (const v of message.clickElements) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primary = GetTestingResultResponse_Statistics.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testing = GetTestingResultResponse_Statistics.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clickElements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResultResponse {
    return {
      primary: isSet(object.primary) ? GetTestingResultResponse_Statistics.fromJSON(object.primary) : undefined,
      testing: isSet(object.testing) ? GetTestingResultResponse_Statistics.fromJSON(object.testing) : undefined,
      clickElements: globalThis.Array.isArray(object?.clickElements)
        ? object.clickElements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetTestingResultResponse): unknown {
    const obj: any = {};
    if (message.primary !== undefined) {
      obj.primary = GetTestingResultResponse_Statistics.toJSON(message.primary);
    }
    if (message.testing !== undefined) {
      obj.testing = GetTestingResultResponse_Statistics.toJSON(message.testing);
    }
    if (message.clickElements?.length) {
      obj.clickElements = message.clickElements;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResultResponse>, I>>(base?: I): GetTestingResultResponse {
    return GetTestingResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResultResponse>, I>>(object: I): GetTestingResultResponse {
    const message = createBaseGetTestingResultResponse();
    message.primary = (object.primary !== undefined && object.primary !== null)
      ? GetTestingResultResponse_Statistics.fromPartial(object.primary)
      : undefined;
    message.testing = (object.testing !== undefined && object.testing !== null)
      ? GetTestingResultResponse_Statistics.fromPartial(object.testing)
      : undefined;
    message.clickElements = object.clickElements?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTestingResultResponse_Statistics(): GetTestingResultResponse_Statistics {
  return { visits: 0, averageTimeOnPage: 0, clickMap: {} };
}

export const GetTestingResultResponse_Statistics: MessageFns<GetTestingResultResponse_Statistics> = {
  encode(message: GetTestingResultResponse_Statistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.visits !== 0) {
      writer.uint32(8).int32(message.visits);
    }
    if (message.averageTimeOnPage !== 0) {
      writer.uint32(17).double(message.averageTimeOnPage);
    }
    Object.entries(message.clickMap).forEach(([key, value]) => {
      GetTestingResultResponse_Statistics_ClickMapEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResultResponse_Statistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResultResponse_Statistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.visits = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.averageTimeOnPage = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = GetTestingResultResponse_Statistics_ClickMapEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.clickMap[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResultResponse_Statistics {
    return {
      visits: isSet(object.visits) ? globalThis.Number(object.visits) : 0,
      averageTimeOnPage: isSet(object.averageTimeOnPage) ? globalThis.Number(object.averageTimeOnPage) : 0,
      clickMap: isObject(object.clickMap)
        ? Object.entries(object.clickMap).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetTestingResultResponse_Statistics): unknown {
    const obj: any = {};
    if (message.visits !== 0) {
      obj.visits = Math.round(message.visits);
    }
    if (message.averageTimeOnPage !== 0) {
      obj.averageTimeOnPage = message.averageTimeOnPage;
    }
    if (message.clickMap) {
      const entries = Object.entries(message.clickMap);
      if (entries.length > 0) {
        obj.clickMap = {};
        entries.forEach(([k, v]) => {
          obj.clickMap[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResultResponse_Statistics>, I>>(
    base?: I,
  ): GetTestingResultResponse_Statistics {
    return GetTestingResultResponse_Statistics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResultResponse_Statistics>, I>>(
    object: I,
  ): GetTestingResultResponse_Statistics {
    const message = createBaseGetTestingResultResponse_Statistics();
    message.visits = object.visits ?? 0;
    message.averageTimeOnPage = object.averageTimeOnPage ?? 0;
    message.clickMap = Object.entries(object.clickMap ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetTestingResultResponse_Statistics_ClickMapEntry(): GetTestingResultResponse_Statistics_ClickMapEntry {
  return { key: "", value: 0 };
}

export const GetTestingResultResponse_Statistics_ClickMapEntry: MessageFns<
  GetTestingResultResponse_Statistics_ClickMapEntry
> = {
  encode(
    message: GetTestingResultResponse_Statistics_ClickMapEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResultResponse_Statistics_ClickMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResultResponse_Statistics_ClickMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResultResponse_Statistics_ClickMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GetTestingResultResponse_Statistics_ClickMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResultResponse_Statistics_ClickMapEntry>, I>>(
    base?: I,
  ): GetTestingResultResponse_Statistics_ClickMapEntry {
    return GetTestingResultResponse_Statistics_ClickMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResultResponse_Statistics_ClickMapEntry>, I>>(
    object: I,
  ): GetTestingResultResponse_Statistics_ClickMapEntry {
    const message = createBaseGetTestingResultResponse_Statistics_ClickMapEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGetTestingRequest(): GetTestingRequest {
  return { productId: "" };
}

export const GetTestingRequest: MessageFns<GetTestingRequest> = {
  encode(message: GetTestingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetTestingRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingRequest>, I>>(base?: I): GetTestingRequest {
    return GetTestingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingRequest>, I>>(object: I): GetTestingRequest {
    const message = createBaseGetTestingRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetTestingResponse(): GetTestingResponse {
  return { data: [] };
}

export const GetTestingResponse: MessageFns<GetTestingResponse> = {
  encode(message: GetTestingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      GetTestingResponse_Testing.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(GetTestingResponse_Testing.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResponse {
    return {
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => GetTestingResponse_Testing.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTestingResponse): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => GetTestingResponse_Testing.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResponse>, I>>(base?: I): GetTestingResponse {
    return GetTestingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResponse>, I>>(object: I): GetTestingResponse {
    const message = createBaseGetTestingResponse();
    message.data = object.data?.map((e) => GetTestingResponse_Testing.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTestingResponse_Testing(): GetTestingResponse_Testing {
  return { id: "", primaryVersionId: "", testingVersionId: "", createdAt: "" };
}

export const GetTestingResponse_Testing: MessageFns<GetTestingResponse_Testing> = {
  encode(message: GetTestingResponse_Testing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.primaryVersionId !== "") {
      writer.uint32(18).string(message.primaryVersionId);
    }
    if (message.testingVersionId !== "") {
      writer.uint32(26).string(message.testingVersionId);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestingResponse_Testing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestingResponse_Testing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primaryVersionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testingVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestingResponse_Testing {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      primaryVersionId: isSet(object.primaryVersionId) ? globalThis.String(object.primaryVersionId) : "",
      testingVersionId: isSet(object.testingVersionId) ? globalThis.String(object.testingVersionId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: GetTestingResponse_Testing): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.primaryVersionId !== "") {
      obj.primaryVersionId = message.primaryVersionId;
    }
    if (message.testingVersionId !== "") {
      obj.testingVersionId = message.testingVersionId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTestingResponse_Testing>, I>>(base?: I): GetTestingResponse_Testing {
    return GetTestingResponse_Testing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTestingResponse_Testing>, I>>(object: I): GetTestingResponse_Testing {
    const message = createBaseGetTestingResponse_Testing();
    message.id = object.id ?? "";
    message.primaryVersionId = object.primaryVersionId ?? "";
    message.testingVersionId = object.testingVersionId ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

export interface TestingService {
  StartTesting(request: StartTestingRequest): Promise<StartTestingResponse>;
  GetRunningTesting(request: GetRunningTestingRequest): Promise<GetRunningTestingResponse>;
  StopTesting(request: StopTestingRequest): Promise<StopTestingResponse>;
  GetTestingResult(request: GetTestingResultRequest): Promise<GetTestingResultResponse>;
  GetTestings(request: GetTestingRequest): Promise<GetTestingResponse>;
}

export const TestingServiceServiceName = "backend.TestingService";
export class TestingServiceClientImpl implements TestingService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TestingServiceServiceName;
    this.rpc = rpc;
    this.StartTesting = this.StartTesting.bind(this);
    this.GetRunningTesting = this.GetRunningTesting.bind(this);
    this.StopTesting = this.StopTesting.bind(this);
    this.GetTestingResult = this.GetTestingResult.bind(this);
    this.GetTestings = this.GetTestings.bind(this);
  }
  StartTesting(request: StartTestingRequest): Promise<StartTestingResponse> {
    const data = StartTestingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StartTesting", data);
    return promise.then((data) => StartTestingResponse.decode(new BinaryReader(data)));
  }

  GetRunningTesting(request: GetRunningTestingRequest): Promise<GetRunningTestingResponse> {
    const data = GetRunningTestingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRunningTesting", data);
    return promise.then((data) => GetRunningTestingResponse.decode(new BinaryReader(data)));
  }

  StopTesting(request: StopTestingRequest): Promise<StopTestingResponse> {
    const data = StopTestingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StopTesting", data);
    return promise.then((data) => StopTestingResponse.decode(new BinaryReader(data)));
  }

  GetTestingResult(request: GetTestingResultRequest): Promise<GetTestingResultResponse> {
    const data = GetTestingResultRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTestingResult", data);
    return promise.then((data) => GetTestingResultResponse.decode(new BinaryReader(data)));
  }

  GetTestings(request: GetTestingRequest): Promise<GetTestingResponse> {
    const data = GetTestingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTestings", data);
    return promise.then((data) => GetTestingResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
